Voici quelques-unes des annotations couramment utilisées dans Java Spring :

@RestController : Cette annotation est utilisée pour marquer une classe comme un contrôleur REST, ce qui permet au framework Spring de comprendre que la classe contient des méthodes qui répondent aux requêtes REST.
@RequestMapping : Cette annotation est utilisée pour mapper les requêtes HTTP aux méthodes du contrôleur correspondant. Elle est souvent utilisée pour définir l'URL de l'API REST.
@Autowired : Cette annotation est utilisée pour injecter automatiquement les dépendances des beans Spring dans une classe. Elle évite ainsi la nécessité de créer des instances manuellement.
@Service : Cette annotation est utilisée pour marquer une classe comme un service. Les classes de service effectuent des opérations métier et peuvent être injectées dans les contrôleurs.
@Repository : Cette annotation est utilisée pour marquer une classe comme un dépôt, c'est-à-dire une classe qui interagit avec la base de données. Les classes de dépôt peuvent être injectées dans les classes de service.
@ModelAttribute : Cette annotation est utilisée pour lier les paramètres d'une requête à un objet Java. Elle est souvent utilisée pour valider les entrées utilisateur avant de les traiter.
@PathVariable : Cette annotation est utilisée pour extraire les variables de chemin d'une URL. Elle est souvent utilisée pour récupérer des données à partir de l'URL de l'API REST.
@Transactional : Cette annotation est utilisée pour gérer les transactions de base de données. Elle assure que toutes les opérations de base de données sont effectuées dans une transaction unique.
@Autowired : Cette annotation est utilisée pour injecter automatiquement les dépendances des beans Spring dans une classe. Elle évite ainsi la nécessité de créer des instances manuellement.
@Bean : Cette annotation est utilisée pour marquer une méthode de configuration qui retourne un bean Spring. Les beans sont des objets gérés par Spring qui peuvent être utilisés dans toute l'application.
@Component : Cette annotation est utilisée pour marquer une classe comme un composant Spring. Les composants sont des objets gérés par Spring qui peuvent être utilisés dans toute l'application.
@Configuration : Cette annotation est utilisée pour marquer une classe de configuration Spring. Les classes de configuration contiennent des méthodes annotées avec @Bean pour créer des beans Spring.
@Controller : Cette annotation est utilisée pour marquer une classe comme un contrôleur Spring. Les contrôleurs sont utilisés pour traiter les requêtes HTTP et générer des réponses.
@RequestMapping : Cette annotation est utilisée pour mapper les requêtes HTTP aux méthodes du contrôleur correspondant. Elle est souvent utilisée pour définir l'URL de l'API REST.
@RestController : Cette annotation est utilisée pour marquer une classe comme un contrôleur REST, ce qui permet au framework Spring de comprendre que la classe contient des méthodes qui répondent aux requêtes REST.
@Service : Cette annotation est utilisée pour marquer une classe comme un service. Les classes de service effectuent des opérations métier et peuvent être injectées dans les contrôleurs.
@Repository : Cette annotation est utilisée pour marquer une classe comme un dépôt, c'est-à-dire une classe qui interagit avec la base de données. Les classes de dépôt peuvent être injectées dans les classes de service.
@Transactional : Cette annotation est utilisée pour gérer les transactions de base de données. Elle assure que toutes les opérations de base de données sont effectuées dans une transaction unique.
@ExceptionHandler : Cette annotation est utilisée pour gérer les exceptions dans une méthode du contrôleur. Elle permet de définir un comportement spécifique pour les erreurs qui se produisent lors de l'exécution de la méthode.
@ModelAttribute : Cette annotation est utilisée pour lier les paramètres d'une requête à un objet Java. Elle est souvent utilisée pour valider les entrées utilisateur avant de les traiter.
@PathVariable : Cette annotation est utilisée pour extraire les variables de chemin d'une URL. Elle est souvent utilisée pour récupérer des données à partir de l'URL de l'API REST.
@RequestBody : Cette annotation est utilisée pour récupérer le corps d'une requête HTTP. Elle permet de récupérer des données envoyées dans la requête HTTP, comme du JSON ou des données de formulaire.
@ResponseBody : Cette annotation est utilisée pour renvoyer le corps d'une réponse HTTP. Elle permet de renvoyer des données dans la réponse HTTP, comme du JSON ou des données XML.
@Value : Cette annotation est utilisée pour injecter des valeurs de propriétés dans une classe. Elle permet de définir des valeurs de configuration dans un fichier de propriétés et de les injecter dans des variables ou des champs de la classe.
@Qualifier : Cette annotation est utilisée pour spécifier le nom ou l'ID d'un bean à injecter lorsqu'il y a plusieurs beans du même type. Elle permet de distinguer les beans qui ont le même type.
@Scope : Cette annotation est utilisée pour définir la portée d'un bean. Elle permet de contrôler le cycle de vie d'un bean dans l'application.
@Scheduled : Cette annotation est utilisée pour planifier l'exécution de méthodes à des intervalles réguliers. Elle permet de définir des tâches planifiées, comme l'envoi de courriels ou la mise à jour de données.
@Async : Cette annotation est utilisée pour exécuter une méthode de manière asynchrone. Elle permet de libérer le thread en cours pour exécuter d'autres tâches en parallèle.
@Cacheable : Cette annotation est utilisée pour mettre en cache le résultat d'une méthode. Elle permet d'améliorer les performances en évitant de répéter des calculs coûteux.
@EnableCaching : Cette annotation est utilisée pour activer la mise en cache dans une application Spring. Elle permet d'activer la mise en cache pour toutes les méthodes annotées avec @Cacheable.
@EnableAsync : Cette annotation est utilisée pour activer l'exécution asynchrone dans une application Spring. Elle permet d'activer l'exécution asynchrone pour toutes les méthodes annotées avec @Async.
@Order : Cette annotation est utilisée pour définir l'ordre d'exécution des bean. Elle permet de spécifier l'ordre dans lequel les bean doivent être créés et initialisés.
@ModelAttribute : Cette annotation est utilisée pour ajouter des attributs de modèle à la réponse. Elle permet de renvoyer des données supplémentaires dans la réponse HTTP, comme des informations d'utilisateur ou des messages d'erreur.
@Profile : Cette annotation est utilisée pour définir des profils pour les environnements de développement, de test et de production. Elle permet de spécifier le comportement d'une application en fonction de l'environnement dans lequel elle est exécutée.
@Conditional : Cette annotation est utilisée pour conditionner la création de bean en fonction de certaines conditions. Elle permet de créer des bean uniquement lorsqu'une condition spécifique est remplie.
@ExceptionHandler : Cette annotation est utilisée pour intercepter les exceptions lancées par une méthode et y réagir. Elle permet de personnaliser la gestion des erreurs dans l'application.
@RestControllerAdvice : Cette annotation est utilisée pour centraliser la gestion des exceptions dans une application REST. Elle permet de traiter les exceptions de manière centralisée et de renvoyer des réponses HTTP cohérentes.
@ResponseStatus : Cette annotation est utilisée pour définir le code de statut HTTP renvoyé par une méthode. Elle permet de personnaliser le code de statut HTTP en fonction du résultat de la méthode.
@PathVariable : Cette annotation est utilisée pour extraire les variables de chemin d'une URL. Elle permet de récupérer des données à partir de l'URL de l'API REST.
@RequestHeader : Cette annotation est utilisée pour extraire les en-têtes d'une requête HTTP. Elle permet de récupérer des informations supplémentaires sur la requête, comme le type de contenu ou l'ID de l'utilisateur.
@RequestBody : Cette annotation est utilisée pour extraire le corps d'une requête HTTP. Elle permet de récupérer des données envoyées dans la requête HTTP, comme du JSON ou des données de formulaire.
@ResponseStatus : Cette annotation est utilisée pour définir le code de statut HTTP renvoyé par une méthode. Elle permet de personnaliser le code de statut HTTP en fonction du résultat de la méthode.
@CrossOrigin : Cette annotation est utilisée pour autoriser les requêtes HTTP cross-origin. Elle permet de définir les origines autorisées pour les requêtes, afin d'éviter les attaques CSRF.
@Valid : Cette annotation est utilisée pour valider les données saisies par l'utilisateur. Elle permet de s'assurer que les données envoyées à l'API REST sont valides avant de les traiter.
@InitBinder : Cette annotation est utilisée pour personnaliser la liaison de données entre le formulaire HTML et le modèle de données. Elle permet de personnaliser la conversion des données et la validation des données.
@ModelAttribute : Cette annotation est utilisée pour lier les paramètres d'une requête à un objet Java. Elle est souvent utilisée pour valider les entrées utilisateur avant de les traiter.
@SessionAttributes : Cette annotation est utilisée pour conserver les attributs de modèle dans une session. Elle permet de stocker les données utilisateur dans la session, afin de les réutiliser entre les requêtes HTTP.
@CacheEvict : Cette annotation est utilisée pour effacer les données mises en cache lorsqu'une méthode est appelée. Elle permet de supprimer des données de la mise en cache lorsque des modifications sont apportées à la source de données.
@CachePut : Cette annotation est utilisée pour mettre à jour les données mises en cache lorsqu'une méthode est appelée. Elle permet de mettre à jour les données dans la mise en cache lorsque des modifications sont apportées à la source de données.
@CacheConfig : Cette annotation est utilisée pour configurer les paramètres de la mise en cache pour une classe ou une méthode spécifique. Elle permet de définir des paramètres de mise en cache comme la durée de vie ou le nombre maximal d'éléments mis en cache.
@EnableJpaRepositories : Cette annotation est utilisée pour activer le support JPA dans une application Spring. Elle permet de définir les packages de dépôt pour une application Spring.
@TransactionalEventListener : Cette annotation est utilisée pour intercepter les événements transactionnels déclenchés par une méthode transactionnelle. Elle permet de personnaliser la gestion des événements transactionnels dans une application Spring.
@Lazy : Cette annotation est utilisée pour retarder l'initialisation d'un bean jusqu'à ce qu'il soit nécessaire. Elle permet d'améliorer les performances en évitant de créer des objets inutiles.
@ValueSource : Cette annotation est utilisée pour fournir des valeurs d'entrée à un test unitaire. Elle permet de fournir des valeurs d'entrée à une méthode de test unitaire.
@BeforeEach : Cette annotation est utilisée pour exécuter du code avant chaque méthode de test unitaire. Elle permet de définir des opérations qui doivent être exécutées avant chaque test.
@AfterEach : Cette annotation est utilisée pour exécuter du code après chaque méthode de test unitaire. Elle permet de définir des opérations qui doivent être exécutées après chaque test.
@SpringBootTest : Cette annotation est utilisée pour exécuter un test d'intégration Spring Boot. Elle permet de tester une application Spring Boot en démarrant le contexte Spring.
@ExtendWith : Cette annotation est utilisée pour étendre les fonctionnalités des tests unitaires JUnit 5. Elle permet d'ajouter des extensions qui fournissent des fonctionnalités supplémentaires pour les tests unitaires JUnit 5.
@MockBean : Cette annotation est utilisée pour créer un bean simulé pour un test unitaire. Elle permet de simuler le comportement d'un bean dans un test unitaire.
@ActiveProfiles : Cette annotation est utilisée pour activer les profils Spring actifs pour un test unitaire. Elle permet de spécifier les profils à utiliser pour un test unitaire.
@DataJpaTest : Cette annotation est utilisée pour tester les fonctionnalités JPA d'une application Spring. Elle permet de tester l'interaction avec la base de données dans une application Spring.
@WebMvcTest : Cette annotation est utilisée pour tester les contrôleurs MVC d'une application Spring. Elle permet de tester les contrôleurs MVC sans démarrer l'application complète.
@MockMvc : Cette annotation est utilisée pour créer un objet MockMvc pour tester les contrôleurs MVC. Elle permet de simuler les requêtes HTTP pour tester les contrôleurs MVC.
@JsonTest : Cette annotation est utilisée pour tester les fonctionnalités de sérialisation et de désérialisation JSON dans une application Spring. Elle permet de tester les conversions JSON dans une application Spring.
@RestClientTest : Cette annotation est utilisée pour tester les clients REST dans une application Spring. Elle permet de tester les clients REST sans démarrer l'application complète.
@SpringBootTest : Cette annotation est utilisée pour exécuter un test d'intégration Spring Boot. Elle permet de tester une application Spring Boot en démarrant le contexte Spring.
@ExtendWith : Cette annotation est utilisée pour étendre les fonctionnalités des tests unitaires JUnit 5. Elle permet d'ajouter des extensions qui fournissent des fonctionnalités supplémentaires pour les tests unitaires JUnit 5.
@WebFluxTest : Cette annotation est utilisée pour tester les contrôleurs WebFlux d'une application Spring. Elle permet de tester les contrôleurs WebFlux sans démarrer l'application complète.
@AutoConfigureMockMvc : Cette annotation est utilisée pour configurer automatiquement l'objet MockMvc pour un test unitaire. Elle permet de simplifier la configuration de l'objet MockMvc pour les tests unitaires.
@AutoConfigureDataJpa : Cette annotation est utilisée pour configurer automatiquement les fonctionnalités JPA pour un test unitaire. Elle permet de simplifier la configuration des fonctionnalités JPA pour les tests unitaires.
@AutoConfigureWebTestClient : Cette annotation est utilisée pour configurer automatiquement l'objet WebTestClient pour un test unitaire. Elle permet de simplifier la configuration de l'objet WebTestClient pour les tests unitaires.
@AutoConfigureJsonTesters : Cette annotation est utilisée pour configurer automatiquement les fonctionnalités de sérialisation et de désérialisation JSON pour un test unitaire. Elle permet de simplifier la configuration des conversions JSON pour les tests unitaires.
@ConditionalOnProperty : Cette annotation est utilisée pour conditionner la création d'un bean en fonction de la présence ou de la valeur d'une propriété dans le fichier de propriétés. Elle permet de définir une condition pour la création d'un bean en fonction de la configuration.
@ConditionalOnClass : Cette annotation est utilisée pour conditionner la création d'un bean en fonction de la présence d'une classe dans le classpath de l'application. Elle permet de définir une condition pour la création d'un bean en fonction de la disponibilité de classes spécifiques.
@Retryable : Cette annotation est utilisée pour annoter une méthode pour une tentative de réessayer en cas d'échec. Elle permet de définir une stratégie de réessai pour une méthode en cas d'échec, par exemple en cas d'erreur de base de données.
@CircuitBreaker : Cette annotation est utilisée pour annoter une méthode pour la mise en place d'un circuit-breaker. Elle permet de protéger une méthode contre les échecs répétés, en limitant les appels à la méthode lorsqu'elle est en panne.
@Fallback : Cette annotation est utilisée pour fournir un fallback pour une méthode annotée avec @CircuitBreaker. Elle permet de fournir une réponse de secours pour une méthode qui est en panne.
@RestControllerAdvice : Cette annotation est utilisée pour centraliser la gestion des exceptions dans une application REST. Elle permet de traiter les exceptions de manière centralisée et de renvoyer des réponses HTTP cohérentes.
@Async : Cette annotation est utilisée pour exécuter une méthode de manière asynchrone. Elle permet de libérer le thread en cours pour exécuter d'autres tâches en parallèle.
@Scheduled : Cette annotation est utilisée pour planifier l'exécution de méthodes à des intervalles réguliers. Elle permet de définir des tâches planifiées, comme l'envoi de courriels ou la mise à jour de données.
@EventListener : Cette annotation est utilisée pour intercepter les événements Spring. Elle permet de réagir aux événements Spring dans une application, comme le démarrage de l'application ou la fin de l'application.
@Value : Cette annotation est utilisée pour injecter des valeurs de propriétés dans une classe. Elle permet de définir des valeurs de configuration dans un fichier de propriétés et de les injecter dans des variables ou des champs de la classe.
@ExceptionHandler : Cette annotation est utilisée pour gérer les exceptions dans une méthode du contrôleur. Elle permet de définir un comportement spécifique pour les erreurs qui se produisent lors de l'exécution de la méthode.
@ModelAttribute : Cette annotation est utilisée pour ajouter des attributs de modèle à la réponse. Elle permet de renvoyer des données supplémentaires dans la réponse HTTP, comme des informations d'utilisateur ou des messages d'erreur.
@PathVariable : Cette annotation est utilisée pour extraire les variables de chemin d'une URL. Elle permet de récupérer des données à partir de l'URL de l'API REST.
@RequestParam : Cette annotation est utilisée pour extraire les paramètres d'une requête HTTP. Elle permet de récupérer des données envoyées dans la requête HTTP, comme des données de formulaire.
@RequestBody : L'annotation @RequestBody en Spring est utilisée pour indiquer qu'un paramètre de méthode doit être lié au corps de la requête HTTP. Lorsqu'un client envoie une requête HTTP POST, PUT ou PATCH, il envoie souvent des données dans le corps de la requête. L'annotation @RequestBody indique à Spring de prendre le contenu du corps de la requête et de le convertir en l'objet Java approprié.
@JsonFormat : Cette annotation est utilisée pour formater les propriétés JSON d'un objet. Elle permet de personnaliser le format des dates et des nombres dans la réponse JSON.
@JsonInclude : Cette annotation est utilisée pour inclure ou exclure des propriétés JSON dans la réponse. Elle permet de contrôler les propriétés JSON renvoyées dans la réponse HTTP.
@JsonIgnore : Cette annotation est utilisée pour exclure une propriété JSON de la réponse. Elle permet de masquer une propriété JSON dans la réponse HTTP.
@JsonProperty : Cette annotation est utilisée pour renommer une propriété JSON dans la réponse. Elle permet de renommer une propriété JSON pour une meilleure lisibilité dans la réponse HTTP.
@JsonView : Cette annotation est utilisée pour filtrer les propriétés JSON dans la réponse. Elle permet de contrôler les propriétés JSON renvoyées dans la réponse HTTP en fonction de la vue de l'utilisateur.
@ExceptionHandler : Cette annotation est utilisée pour gérer les exceptions dans une méthode du contrôleur. Elle permet de définir un comportement spécifique pour les erreurs qui se produisent lors de l'exécution de la méthode.
@ModelAttribute : Cette annotation est utilisée pour ajouter des attributs de modèle à la réponse. Elle permet de renvoyer des données supplémentaires dans la réponse HTTP, comme des informations d'utilisateur ou des messages d'erreur.
@RequestMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL. Elle permet de définir l'URL à laquelle une méthode de contrôleur doit répondre.
@GetMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL avec la méthode HTTP GET. Elle permet de définir l'URL et la méthode HTTP à laquelle une méthode de contrôleur doit répondre.
@PostMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL avec la méthode HTTP POST. Elle permet de définir l'URL et la méthode HTTP à laquelle une méthode de contrôleur doit répondre.
@PutMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL avec la méthode HTTP PUT. Elle permet de définir l'URL et la méthode HTTP à laquelle une méthode de contrôleur doit répondre.
@DeleteMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL avec la méthode HTTP DELETE. Elle permet de définir l'URL et la méthode HTTP à laquelle une méthode de contrôleur doit répondre.
@ExceptionHandler : Cette annotation est utilisée pour intercepter les exceptions lancées par une méthode et y réagir. Elle permet de personnaliser la gestion des erreurs dans l'application.
@ResponseStatus : Cette annotation est utilisée pour définir le code de statut HTTP renvoyé par une méthode. Elle permet de personnaliser le code de statut HTTP en fonction du résultat de la méthode.
@RequestBody : Cette annotation est utilisée pour extraire le corps d'une requête HTTP. Elle permet de récupérer des données envoyées dans la requête HTTP, comme du JSON ou des données de formulaire.
@RequestHeader : Cette annotation est utilisée pour extraire les en-têtes d'une requête HTTP. Elle permet de récupérer des informations supplémentaires sur la requête, comme le type de contenu ou l
@ResponseBody : Cette annotation est utilisée pour renvoyer des données dans le corps de la réponse HTTP. Elle permet de renvoyer des données sous forme de JSON ou de XML dans la réponse HTTP.
@ResponseStatus : Cette annotation est utilisée pour définir le code de statut HTTP renvoyé par une méthode. Elle permet de personnaliser le code de statut HTTP en fonction du résultat de la méthode.
@PathVariable : Cette annotation est utilisée pour extraire les variables de chemin d'une URL. Elle permet de récupérer des données à partir de l'URL de l'API REST.
@RequestParam : Cette annotation est utilisée pour extraire les paramètres d'une requête HTTP. Elle permet de récupérer des données envoyées dans la requête HTTP, comme des données de formulaire.
@RequestHeader : Cette annotation est utilisée pour extraire les en-têtes d'une requête HTTP. Elle permet de récupérer des informations supplémentaires sur la requête, comme le type de contenu ou la langue de la requête.
@RequestPart : Cette annotation est utilisée pour extraire les parties d'un corps de requête HTTP multipart. Elle permet de récupérer des données envoyées dans une requête HTTP multipart, comme des fichiers ou des images.
@ControllerAdvice : Cette annotation est utilisée pour définir un conseiller global pour les contrôleurs de l'application. Elle permet de définir des opérations à exécuter avant ou après l'exécution de chaque méthode de contrôleur.
@ComponentScan : Cette annotation est utilisée pour scanner les composants de l'application Spring. Elle permet de rechercher les classes annotées avec @Component, @Service ou @Repository et de les enregistrer dans le contexte Spring.
@Autowired : Cette annotation est utilisée pour injecter des dépendances dans une classe. Elle permet d'injecter automatiquement une dépendance dans une classe, sans avoir à instancier manuellement la dépendance.
@Qualifier : Cette annotation est utilisée pour spécifier un nom de bean lors de l'injection de dépendances. Elle permet de spécifier un bean à utiliser lorsque plusieurs beans sont disponibles pour l'injection.
@Profile : Cette annotation est utilisée pour activer les profils Spring pour une classe ou une méthode spécifique. Elle permet de définir les profils à utiliser pour une classe ou une méthode dans une application Spring.
@Value : Cette annotation est utilisée pour injecter des valeurs de propriétés dans une classe. Elle permet de définir des valeurs de configuration dans un fichier de propriétés et de les injecter dans des variables ou des champs de la classe.
@Bean : Cette annotation est utilisée pour définir un bean dans le contexte Spring. Elle permet de créer un bean personnalisé et de le rendre disponible pour l'injection de dépendances.
@Configuration : Cette annotation est utilisée pour définir une configuration dans une application Spring. Elle permet de configurer les beans et les dépendances dans l'application Spring.
@Async : Cette annotation est utilisée pour exécuter une méthode de manière asynchrone. Elle permet de libérer le thread en cours pour exécuter d'autres tâches en parallèle.
@Cacheable : Cette annotation est utilisée pour activer la mise en cache pour une méthode de l'application. Elle permet de stocker en cache le résultat d'une méthode pour une exécution plus rapide ultérieure.
@CacheEvict : Cette annotation est utilisée pour supprimer une entrée de cache pour une méthode de l'application. Elle permet de supprimer l'entrée de cache pour une méthode spécifique.
@CachePut : Cette annotation est utilisée pour mettre à jour une entrée de cache pour une méthode de l'application. Elle permet de mettre à jour l'entrée de cache pour une méthode spécifique.
@Transactional : Cette annotation est utilisée pour activer la gestion de transaction pour une méthode de l'application. Elle permet de garantir que la méthode est exécutée dans une transaction.
@EnableScheduling : Cette annotation est utilisée pour activer la planification des tâches dans l'application. Elle permet de définir les tâches à exécuter à des intervalles réguliers dans l'application.
@CrossOrigin : Cette annotation est utilisée pour autoriser les demandes CORS pour une méthode de l'application. Elle permet de définir les autorisations pour les demandes CORS pour une méthode spécifique.
@Conditional : Cette annotation est utilisée pour conditionner la création d'un bean en fonction d'une condition. Elle permet de définir une condition pour la création d'un bean en fonction de la configuration.
@Retryable : Cette annotation est utilisée pour annoter une méthode pour une tentative de réessayer en cas d'échec. Elle permet de définir une stratégie de réessai pour une méthode en cas d'échec, par exemple en cas d'erreur de base de données.
@CircuitBreaker : Cette annotation est utilisée pour annoter une méthode pour la mise en place d'un circuit-breaker. Elle permet de protéger une méthode contre les échecs répétés, en limitant les appels à la méthode lorsqu'elle est en panne.
@Fallback : Cette annotation est utilisée pour fournir un fallback pour une méthode annotée avec @CircuitBreaker. Elle permet de fournir une réponse de secours pour une méthode qui est en panne.
@Service : Cette annotation est utilisée pour indiquer que la classe est un service de l'application. Elle permet de marquer une classe comme un service et de la rendre disponible pour l'injection de dépendances.
@Repository : Cette annotation est utilisée pour indiquer que la classe est un référentiel de données de l'application. Elle permet de marquer une classe comme un référentiel et de la rendre disponible pour l'injection de dépendances.
@Controller : Cette annotation est utilisée pour indiquer que la classe est un contrôleur de l'application. Elle permet de marquer une classe comme un contrôleur et de la rendre disponible pour l'injection de dépendances.
@RestController : Cette annotation est utilisée pour indiquer que la classe est un contrôleur REST de l'application. Elle permet de marquer une classe comme un contrôleur REST et de la rendre disponible pour l'injection
@ModelAttribute : Cette annotation est utilisée pour ajouter des attributs de modèle à la réponse. Elle permet de renvoyer des données supplémentaires dans la réponse HTTP, comme des informations d'utilisateur ou des messages d'erreur.
@SessionAttributes : Cette annotation est utilisée pour stocker des attributs de modèle dans la session HTTP. Elle permet de stocker des données de session pour une utilisation ultérieure dans l'application.
@SessionScope : Cette annotation est utilisée pour définir la portée d'un bean en tant que portée de session HTTP. Elle permet de définir la portée d'un bean pour qu'il soit stocké dans la session HTTP.
@ModelAttribute : Cette annotation est utilisée pour extraire des paramètres de requête HTTP dans des objets Java. Elle permet de mapper les paramètres de requête HTTP dans des objets Java pour une manipulation facile des données.
@RestControllerAdvice : Cette annotation est utilisée pour centraliser la gestion des exceptions dans une application REST. Elle permet de traiter les exceptions de manière centralisée et de renvoyer des réponses HTTP cohérentes.
@ResponseStatus : Cette annotation est utilisée pour définir le code de statut HTTP renvoyé par une méthode. Elle permet de personnaliser le code de statut HTTP en fonction du résultat de la méthode.
@JsonInclude : Cette annotation est utilisée pour inclure ou exclure des propriétés JSON dans la réponse. Elle permet de contrôler les propriétés JSON renvoyées dans la réponse HTTP.
@JsonView : Cette annotation est utilisée pour filtrer les propriétés JSON dans la réponse. Elle permet de contrôler les propriétés JSON renvoyées dans la réponse HTTP en fonction de la vue de l'utilisateur.
@JsonTypeInfo : Cette annotation est utilisée pour inclure des informations de type dans la réponse JSON. Elle permet de définir des informations de type dans la réponse JSON pour faciliter la désérialisation des objets.
@JsonSubTypes : Cette annotation est utilisée pour définir des sous-types pour une classe abstraite. Elle permet de définir des sous-types pour une classe abstraite dans la réponse JSON.
@RequestMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL. Elle permet de définir l'URL à laquelle une méthode de contrôleur doit répondre.
@GetMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL avec la méthode HTTP GET. Elle permet de définir l'URL et la méthode HTTP à laquelle une méthode de contrôleur doit répondre.
@PostMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL avec la méthode HTTP POST. Elle permet de définir l'URL et la méthode HTTP à laquelle une méthode de contrôleur doit répondre.
@PutMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL avec la méthode HTTP PUT. Elle permet de définir l'URL et la méthode HTTP à laquelle une méthode de contrôleur doit répondre.
@DeleteMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL avec la méthode HTTP DELETE. Elle permet de définir l'URL et la méthode HTTP à laquelle une méthode de contrôleur doit répondre.
@ExceptionHandler : The @ExceptionHandler annotation in Spring is used to handle exceptions thrown by a method in a controller or a handler. It provides a way to define a method that handles exceptions for all methods within a controller, allowing for customized error handling and responses to be returned to the client. When an exception occurs, the framework will look for an @ExceptionHandler annotated method in the controller or its parent classes, and will invoke it to handle the exception. The method should return a response entity, which can include a status code, an error message, and other relevant information.
@ControllerAdvice : Cette annotation est utilisée pour définir un conseiller global pour les contrôleurs de l'application. Elle permet de définir des opérations à exécuter avant ou après l'exécution de chaque méthode de contrôleur.
@EnableWebMvc : Cette annotation est utilisée pour activer la configuration de Spring MVC dans l'application. Elle permet de configurer Spring MVC pour l'application Web.
@PathVariable : Cette annotation est utilisée pour extraire les variables de chemin d'une URL. Elle permet de récupérer des données à partir de l'URL de l'API REST.
@RequestParam : Cette annotation est utilisée pour extraire les paramètres d'une requête HTTP. Elle permet de récupérer des données envoyées dans la requête HTTP, comme des données de formulaire.
@RequestHeader : Cette annotation est utilisée pour extraire les en-têtes d'une requête HTTP. Elle permet de récupérer des informations supplémentaires sur la requête, comme le type de contenu ou la langue de la requête.
@RequestBody : Cette annotation est utilisée pour extraire le corps d'une requête HTTP. Elle permet de récupérer des données envoyées dans la requête HTTP, comme du JSON ou des données de formulaire.
@ResponseBody : Cette annotation est utilisée pour renvoyer des données dans le corps de la réponse HTTP. Elle permet de renvoyer des données sous forme de JSON ou de XML dans la réponse HTTP.
@ResponseStatus : Cette annotation est utilisée pour définir le code de statut HTTP renvoyé par une méthode. Elle permet de personnaliser le code de statut HTTP en fonction du résultat de la méthode.
@ExceptionHandler : Cette annotation est utilisée pour intercepter les exceptions lancées par une méthode et y réagir. Elle permet de personnaliser la gestion des erreurs dans l'application.
@ModelAttribute : Cette annotation est utilisée pour ajouter des attributs de modèle à la réponse. Elle permet de renvoyer des données supplémentaires dans la réponse HTTP, comme des informations d'utilisateur ou des messages d'erreur.
@SessionAttributes : Cette annotation est utilisée pour stocker des attributs de modèle dans la session HTTP. Elle permet de stocker des données de session pour une utilisation ultérieure dans l'application.
@RequestMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL. Elle permet de définir l'URL à laquelle une méthode de contrôleur doit répondre.
@GetMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL avec la méthode HTTP GET. Elle permet de définir l'URL et la méthode HTTP à laquelle une méthode de contrôleur doit répondre.
@PostMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL avec la méthode HTTP POST. Elle permet de définir l'URL et la méthode HTTP à laquelle une méthode de contrôleur doit répondre.
@PutMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL avec la méthode HTTP PUT. Elle permet de définir l'URL et la méthode HTTP à laquelle une méthode de contrôleur doit répondre.
@DeleteMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL avec la méthode HTTP DELETE. Elle permet de définir l'URL et la méthode HTTP à laquelle une méthode de contrôleur doit répondre.
@ExceptionHandler : Cette annotation est utilisée pour intercepter les exceptions lancées par une méthode et y réagir. Elle permet de personnaliser la gestion des erreurs dans l'application.
@ResponseBody : Cette annotation est utilisée pour renvoyer des données dans le corps de la réponse HTTP. Elle permet de renvoyer des données sous forme de JSON ou de XML dans la réponse HTTP.
@ResponseStatus : Cette annotation est utilisée pour définir le code de statut HTTP renvoyé par une méthode. Elle permet de personnaliser le code de statut HTTP en fonction du résultat de la méthode.
@PathVariable : Cette annotation est utilisée pour extraire les variables de chemin d'une URL. Elle permet de récupérer des données à partir de l'URL de l'API REST.
@RequestParam : Cette annotation est utilisée pour extraire les paramètres d'une requête HTTP. Elle permet de récupérer des données envoyées dans la requête HTTP, comme des données de formulaire.
@RequestHeader : Cette annotation est utilisée pour extraire les en-têtes d'une requête HTTP. Elle permet de récupérer des informations supplémentaires sur la requête, comme le type de contenu ou la langue de la requête.
@RequestBody : Cette annotation est utilisée pour extraire le corps d'une requête HTTP. Elle permet de récupérer des données envoyées dans la requête HTTP, comme du JSON ou des données de formulaire.
@InitBinder : Cette annotation est utilisée pour personnaliser le processus de liaison de données lors de la soumission d'un formulaire. Elle permet de personnaliser la validation des données dans les formulaires.
@ExceptionHandler : Cette annotation est utilisée pour intercepter les exceptions lancées par une méthode et y réagir. Elle permet de personnaliser la gestion des erreurs dans l'application.
@GetMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL avec la méthode HTTP GET. Elle permet de définir l'URL et la méthode HTTP à laquelle une méthode de contrôleur doit répondre.
@PostMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL avec la méthode HTTP POST. Elle permet de définir l'URL et la méthode HTTP à laquelle une méthode de contrôleur doit répondre.
@PutMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL avec la méthode HTTP PUT. Elle permet de définir l'URL et la méthode HTTP à laquelle une méthode de contrôleur doit répondre.
@DeleteMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une URL avec la méthode HTTP DELETE. Elle permet de définir l'URL et la méthode HTTP à laquelle une méthode de contrôleur doit répondre.
@ExceptionHandler : Cette annotation est utilisée pour intercepter les exceptions lancées par une méthode et y réagir. Elle permet de personnaliser la gestion des erreurs dans l'application.
@ExceptionHandler : Cette annotation est utilisée pour intercepter les exceptions lancées par une méthode et y réagir. Elle permet de personnaliser la gestion des erreurs dans l'application.
@ExceptionHandler : Cette annotation est utilisée pour intercepter les exceptions lancées par une méthode et y réagir. Elle permet de personnaliser la gestion des erreurs dans l'application.
@Transactional : Cette annotation est utilisée pour marquer une méthode ou une classe comme transactionnelle. Elle permet de gérer automatiquement les transactions dans une application.
@Cacheable : Cette annotation est utilisée pour ajouter des données dans un cache pour une récupération plus rapide. Elle permet de stocker les données les plus fréquemment consultées dans un cache pour une récupération plus rapide.
@CachePut : Cette annotation est utilisée pour mettre à jour des données dans le cache. Elle permet de mettre à jour les données stockées dans un cache pour une récupération plus rapide.
@CacheEvict : Cette annotation est utilisée pour supprimer des données du cache. Elle permet de supprimer les données stockées dans un cache pour une récupération plus rapide.
@Scheduled : Cette annotation est utilisée pour planifier l'exécution de méthodes à des intervalles réguliers. Elle permet de planifier l'exécution de méthodes pour des tâches de maintenance ou de nettoyage.
@Async : Cette annotation est utilisée pour marquer une méthode comme asynchrone. Elle permet d'exécuter des tâches en arrière-plan sans bloquer le thread principal.
@Value : Cette annotation est utilisée pour injecter des valeurs de propriétés à partir d'un fichier de configuration. Elle permet de configurer les valeurs de propriétés à partir d'un fichier de configuration sans avoir à les coder en dur.
@ConfigurationProperties : Cette annotation est utilisée pour lier des propriétés à des objets. Elle permet de lier les valeurs de propriétés à des objets pour une manipulation facile des données.
@EnableConfigurationProperties : Cette annotation est utilisée pour activer la liaison des propriétés de configuration à des objets. Elle permet d'activer la liaison des valeurs de propriétés à des objets dans l'application.
@Conditional : Cette annotation est utilisée pour activer une configuration conditionnelle en fonction de certaines conditions. Elle permet de personnaliser la configuration de l'application en fonction de certains critères.
@EnableCaching : Cette annotation est utilisée pour activer la mise en cache dans l'application. Elle permet d'activer la mise en cache pour des performances accrues dans l'application.
@Import : Cette annotation est utilisée pour importer une configuration à partir d'une autre classe. Elle permet d'importer des configurations à partir d'autres classes dans l'application.
@Bean : Cette annotation est utilisée pour définir un bean dans le contexte Spring. Elle permet de définir un objet qui sera géré par le conteneur Spring.
@ComponentScan : Cette annotation est utilisée pour scanner les classes et détecter les beans à gérer par Spring. Elle permet de détecter automatiquement les classes à gérer en tant que beans Spring.
@Autowired : Cette annotation est utilisée pour injecter une dépendance dans une classe. Elle permet d'injecter automatiquement une dépendance dans une classe.
@Entity : Cette annotation est utilisée pour marquer une classe comme une entité persistante dans la base de données. Elle permet de mapper une classe à une table de base de données.
@Table : Cette annotation est utilisée pour définir le nom de la table de base de données correspondant à une entité. Elle permet de personnaliser le nom de la table de base de données correspondant à une classe.
@Id : Cette annotation est utilisée pour définir la clé primaire d'une entité. Elle permet de définir la propriété de la classe qui sert de clé primaire dans la table de base de données.
@GeneratedValue : Cette annotation est utilisée pour générer automatiquement la valeur de la clé primaire lors de l'ajout d'une entité dans la base de données. Elle permet de générer automatiquement une valeur pour la clé primaire de la classe.
@ManyToOne : Cette annotation est utilisée pour définir une relation many-to-one entre deux entités. Elle permet de définir une relation où plusieurs enregistrements d'une table sont liés à un seul enregistrement d'une autre table.
@OneToMany : Cette annotation est utilisée pour définir une relation one-to-many entre deux entités. Elle permet de définir une relation où un enregistrement d'une table est lié à plusieurs enregistrements d'une autre table.
@ManyToMany : Cette annotation est utilisée pour définir une relation many-to-many entre deux entités. Elle permet de définir une relation où plusieurs enregistrements d'une table sont liés à plusieurs enregistrements d'une autre table.
@JoinTable : Cette annotation est utilisée pour définir la table de jointure pour une relation many-to-many. Elle permet de personnaliser la table de jointure utilisée pour une relation many-to-many entre deux entités.
@JoinColumn : Cette annotation est utilisée pour définir la colonne de jointure pour une relation many-to-one ou one-to-many. Elle permet de personnaliser la colonne de jointure utilisée pour lier deux entités.
@Query : Cette annotation est utilisée pour définir une requête SQL personnalisée pour une méthode de repository. Elle permet de définir une requête SQL personnalisée pour récupérer des données de la base de données.
@NamedQueries : Cette annotation est utilisée pour définir des requêtes nommées pour une entité. Elle permet de définir des requêtes nommées pour récupérer des données de la base de données.
@Formula : Cette annotation est utilisée pour définir une expression SQL calculée pour une propriété d'une entité. Elle permet de définir une expression SQL qui sera calculée automatiquement pour une propriété d'une entité.
@TransactionalEventListener : Cette annotation est utilisée pour définir un auditeur d'événements transactionnels. Elle permet de définir une méthode qui sera appelée après la validation d'une transaction.
@EventListener : Cette annotation est utilisée pour définir un auditeur d'événements non transactionnels. Elle permet de définir une méthode qui sera appelée lorsqu'un événement est publié.
@MessageMapping : Cette annotation est utilisée pour mapper une méthode de contrôleur à une destination de messagerie. Elle permet de définir une méthode qui sera appelée lorsqu'un message est envoyé à une destination de messagerie spécifique.
@SendTo : Cette annotation est utilisée pour spécifier la destination à laquelle une méthode de contrôleur doit envoyer un message. Elle permet de renvoyer un message à une destination de messagerie spécifique après qu'une méthode de contrôleur a été exécutée.
@MessagingGateway : Cette annotation est utilisée pour définir une interface de passerelle de messagerie. Elle permet de définir une interface qui peut être utilisée pour envoyer des messages à une destination de messagerie spécifique.
@JmsListener : Cette annotation est utilisée pour définir un auditeur de messages JMS. Elle permet de définir une méthode qui sera appelée lorsqu'un message est reçu à partir d'une file d'attente ou d'un sujet JMS.
@EnableJms : Cette annotation est utilisée pour activer la prise en charge de JMS dans l'application. Elle permet d'activer la prise en charge de JMS pour la messagerie dans l'application.
@ConditionalOnProperty : Cette annotation est utilisée pour activer une configuration conditionnelle en fonction de la valeur d'une propriété de configuration. Elle permet de personnaliser la configuration de l'application en fonction de la valeur d'une propriété de configuration.
@Profile : Cette annotation est utilisée pour activer une configuration conditionnelle en fonction du profil d'exécution de l'application. Elle permet de personnaliser la configuration de l'application en fonction de l'environnement d'exécution.
@ValueSource : Cette annotation est utilisée pour fournir des valeurs à un test paramétré. Elle permet de fournir des valeurs d'entrée à un test paramétré dans les tests unitaires.
@Test : Cette annotation est utilisée pour indiquer qu'une méthode est un test unitaire. Elle permet de définir des tests unitaires pour vérifier le comportement des méthodes de l'application.
@Before : Cette annotation est utilisée pour définir une méthode qui doit être exécutée avant chaque méthode de test. Elle permet de définir une méthode qui sera exécutée avant chaque test unitaire.
@After : Cette annotation est utilisée pour définir une méthode qui doit être exécutée après chaque méthode de test. Elle permet de définir une méthode qui sera exécutée après chaque test unitaire.
@BeforeClass : Cette annotation est utilisée pour définir une méthode qui doit être exécutée avant la première méthode de test. Elle permet de définir une méthode qui sera exécutée avant la première méthode de test dans une classe de test.
@AfterClass : Cette annotation est utilisée pour défin
@SpringBootTest : Cette annotation est utilisée pour définir une classe de test qui doit être exécutée avec Spring Boot. Elle permet de tester une application Spring Boot avec des tests unitaires.
@WebMvcTest : Cette annotation est utilisée pour définir une classe de test qui teste une couche de contrôleur de l'application Spring MVC. Elle permet de tester le comportement d'une couche de contrôleur de l'application.
@DataJpaTest : Cette annotation est utilisée pour définir une classe de test qui teste l'intégration de la couche de persistance de l'application avec la base de données. Elle permet de tester le comportement de la couche de persistance avec la base de données.
@RestClientTest : Cette annotation est utilisée pour définir une classe de test qui teste les clients REST dans l'application. Elle permet de tester les clients REST de l'application.
@ActiveProfiles : Cette annotation est utilisée pour activer des profils d'environnement spécifiques dans les tests unitaires. Elle permet de personnaliser l'environnement d'exécution des tests unitaires.
@Sql : Cette annotation est utilisée pour exécuter des scripts SQL avant ou après l'exécution d'un test unitaire. Elle permet de préparer la base de données avant l'exécution du test unitaire.
@FlywayTest : Cette annotation est utilisée pour tester les migrations de base de données dans l'application. Elle permet de tester les migrations de base de données dans une application Spring.
@TestConfiguration : Cette annotation est utilisée pour définir une classe de configuration spécifique pour les tests unitaires. Elle permet de personnaliser la configuration de l'application pour les tests unitaires.
@MockBean : Cette annotation est utilisée pour créer un mock d'une dépendance dans une classe de test. Elle permet de remplacer une dépendance réelle par un mock dans les tests unitaires.
@SpyBean : Cette annotation est utilisée pour créer un spy d'une dépendance dans une classe de test. Elle permet de surveiller une dépendance réelle dans les tests unitaires.
@MockMvc : Cette annotation est utilisée pour injecter une instance de MockMvc dans une classe de test. Elle permet de simuler une requête HTTP dans un test unitaire.
@WebTestClient : Cette annotation est utilisée pour injecter une instance de WebTestClient dans une classe de test. Elle permet de simuler une requête HTTP dans un test unitaire avec un client WebFlux.
@Timeout : Cette annotation est utilisée pour définir un délai limite pour un test unitaire. Elle permet de définir une limite de temps pour l'exécution d'un test unitaire.
@Disabled : Cette annotation est utilisée pour désactiver un test unitaire. Elle permet de désactiver temporairement un test unitaire sans le supprimer du code source.
